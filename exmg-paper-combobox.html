<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-menu-button/paper-menu-button.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-input/paper-input-error.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../web-animations/web-animations-next.min.html">

<dom-module id="exmg-paper-combobox">
  <template>

  </template>
  <script>
  {
    'use strict';
    /**
    * `exmg-paper-combobox` is an element to show input data
    *
    * @customElement
    * @polymer
    * @group Exmg Elements
    * @element exmg-paper-combobox
    * @demo demo/index.html
    * @memberof Exmg
    * @extends Polymer.Element
    * @summary Paper Combobox Element
    */
    class PaperComboboxElement extends Polymer.Element {
      static get is() {
        return 'exmg-paper-combobox';
      }
      static get properties() {
        return {
          /**
          * If you want to use an attribute value or property of an element for
          * `selected` instead of the index, set this to the name of the attribute
          * or property. Hyphenated values are converted to camel case when used to
          * look up the property of a selectable element. Camel cased values are
          * *not* converted to hyphenated values for attribute lookup. It's
          * recommended that you provide the hyphenated form of the name so that
          * selection works in both cases. (Use `attr-or-property-name` instead of
          * `attrOrPropertyName`.)
          */
          attrForSelected: {
            type: String,
            value: null
          },

          /**
            * By default the textContent of the paper-item/paper-icon-item or paper-item-body
            * will be used for display in badge after selection. In case of icon and body
            * you probably want an alternative. The selector can be used to be a bit more
            * specific on which element can be used for display purposes.
            */
          selectedItemSelector: {
            type: String,
            value: null
          },

          /**
          * Returns currently selected item.
          */
          selectedItem: {
            type: Object,
            notify: true,
          },

          /**
          * The label for this input.
          */
          label: String,

          /**
            * Set to true to auto-validate the input value.
            */
          autoValidate: {
            type: Boolean,
            value: false
          },

          autofocus: {
            type: Boolean
          },

          /**
          * Set to true to disable this input.
          */
          disabled: {
            type: Boolean,
            value: false
          },

          /**
          * The error message to display when the input is invalid.
          */
          errorMessage: {
            type: String
          },

          /**
          * alwaysFloatLabel
          */
          alwaysFloatLabel: {
            type: Boolean,
            value: false
          },

          /**
            * Set to true to mark the input as required. If you're using PaperInputBehavior to
            * implement your own paper-input-like element, bind this to
            * the `<input is="iron-input">`'s `required` property.
            */
          required: {
            type: Boolean,
            value: false
          },

          /**
          * This field will be bind to the actual input field
          */
          _inputValue: {
            type: String,
          },

          invalid: {
            type: Boolean,
          },

          inputFocused: {
            type: Boolean,
          },

          selected: {
            type: Object,
            notify: true,
          },
        };
      }

      static get template() {
        return Polymer.html`
          <style>
            :host {
              display: block;
              @apply --layout-horizontal;
            }
            paper-input-container {
              @apply --layout-flex;
            }
            .tokens {
              margin-right: 6px;
              min-height: 24px;
              position: relative;
              width: 100%;
            }
            .tokens paper-button {
              margin: 0px 0;
              height: 22px;
              font-size: 16px;
              min-width: initial;
              max-width: 100%
            }
            .tokens paper-button span {
              overflow: hidden;
              white-space: nowrap;
              text-overflow: ellipsis;
            }
            .tokens paper-button iron-icon {
              height: 16px;
              width: 16px;
            }
            #inputValue {
              font: inherit;
              outline: none;
              box-shadow: none;
              background: transparent;
              border: none;
              width: auto;
              max-width: 100%;
              min-width: 1.8em;
            }
            paper-menu-button {
              padding: 8px 0;
            }
            paper-icon-button {
              margin: 8px 0;
            }
            paper-button {
              padding: 0;
            }
            .container {
              @apply --layout-flex;
            }
            #listbox {
              min-width: 125px;
              padding: 12.5px;
            }
          </style>
          <paper-input-container
            always-float-label="[[_computeAlwaysFloatLabel(_token, alwaysFloatLabel)]]"
            on-tap="_handleContainerTap"
            disabled$="[[disabled]]"
            focused="{{inputFocused}}"
            invalid="[[invalid]]"
            id="paperInputContainer">

            <label slot="label" hidden$="[[!label]]" aria-hidden="true">[[label]]</label>
            <iron-input bind-value="{{_inputValue}}" slot="input">
              <span class="tokens">
                <template
                  is="dom-if"
                  if="[[_token]]">
                  <paper-button
                    tabindex="-1"
                    on-tap="_handleDeleteToken">[[_token.text]]</paper-button>
                </template>
                <input
                  id="inputValue"
                  aria-labelledby="label"
                  value="{{_inputValue::input}}"
                  autofocus$="[[autofocus]]"
                  autocomplete="off"
                  disabled$="[[disabled]]">
              </span>
            </iron-input>
            <paper-input-error slot="add-on" aria-live="assertive">[[errorMessage]]</paper-input-error>
          </paper-input-container>

          <span id="inputWidthHelper">[[_inputValue]] </span>

          <paper-menu-button id="menu" close-on-activate opened="{{opened}}" vertical-offset="60" horizontal-align="right" restore-focus-on-close disabled$="[[disabled]]">
            <paper-icon-button data-opened$="[[opened]]" class="dropdown-trigger"></paper-icon-button>
            <paper-listbox
              id="listbox"
              slot="dropdown-content"
              selectable="paper-item:not([hidden]),paper-icon-item:not([hidden])"
              attr-for-selected="{{attrForSelected}}"
              selected="{{selected}}"
              class="dropdown-content"
              selected-item="{{selectedItem}}"
              on-iron-select="_handleAddToken" on-iron-deselect="_resetInput">
              <slot></slot>
            </paper-listbox>
          </paper-dropdown-menu>
      `}

      static get observers() {
        return [
          '_observeInputChange(_inputValue)',
          '_observeSelectedItem(selectedItem)',
        ];
      }

      _observeInputChange(_inputValue) {
        console.log('Change!', _inputValue);

        this.$.inputValue.style.width = (this.$.inputWidthHelper.offsetWidth + 10) + 'px';
        this._filterItems();
      };

      _observeSelectedItem(selectedItem) {
        if(!selectedItem) {
          this.set('_token', null);
          return;
        }

        const id = this.attrForSelected ? selectedItem.getAttribute(this.attrForSelected) : this.indexOf(selectedItem);
        const text = this.selectedItemSelector ? selectedItem.querySelector(this.selectedItemSelector).textContent
            : selectedItem.textContent;
        
        this.set('_token', {id, text});
      };

      _handleDeleteToken(e) {
        this.focus();
      };

      indexOf(item) {
        return this.$.listbox.items ? this.$.listbox.items.indexOf(item) : -1;
      };

      _handleClick(e) {
        console.log('click!', e);
        
        const inside = e.path.find((path) => path === this);
        // Detect outside element click for auto validate input
        if (this.autoValidate && !inside && this.previousInsideClick) {
          this.validate();
        }
        this.previousInsideClick = inside;
      };

      _handleAddToken(e) {
        console.log('Token', e);

        e.stopPropagation();
        this._resetInput();
      };

      _filterItems() {
        const items = this.querySelectorAll('paper-item,paper-icon-item');
        for (var i = 0; i < items.length; i++) {
          if (this._inputValue.length > 0 && items[i].textContent.indexOf(this._inputValue) === -1) {
            items[i].setAttribute('hidden', '');
          } else {
            items[i].removeAttribute('hidden');
          }
        }
      };

      connectedCallback() {
        super.connectedCallback();

        this._boundKeyDown = this._handleKeyDown.bind(this);
        this._boundOutsideClick = this._handleClick.bind(this);

        /* Initialize the input helper span element for determining the actual width of the input
          text. This width will be used to create a dynamic width on the input field */

        this.$.inputWidthHelper.style = window.getComputedStyle(this.$.inputValue, null).cssText;
        this.$.inputWidthHelper.style.position = 'absolute';
        this.$.inputWidthHelper.style.top = '-999px';
        this.$.inputWidthHelper.style.left = '0';
        this.$.inputWidthHelper.style.padding = '0';
        this.$.inputWidthHelper.style.width = 'auto';
        this.$.inputWidthHelper.style['white-space'] = 'pre';

        console.log('this.$.inputValue ::: ', this.$.inputValue);

        this.$.inputValue.addEventListener('keydown', this._boundKeyDown);

        if (this.autoValidate) {
          window.addEventListener('click', this._boundOutsideClick);
        }
      };

      disconnectedCallback() {
        super.disconnectedCallback();

        this.$.inputValue.removeEventListener('keydown', this._boundKeyDown);

        if (this.autoValidate) {
          window.removeEventListener('click', this._boundOutsideClick);
        }
      };

      _handleKeyDown(e) {
        console.log('key!', e);

        this._inputValue = this._inputValue || '';
        const BACKSPACE = 8;
        const ARROWDOWN = 40;
        switch (e.keyCode) {
          case BACKSPACE:
            this.reset();
            break;
          case ARROWDOWN:
            this.opened = true;
            this.$.listbox.focus();
            break;
          default:
            this.opened = true;
            Polymer.RenderStatus.afterNextRender(this, _ => this.focus());
            break;
        }
      };

      _hasSelectedItem() {
        return this.selectedItem !== undefined && this.selectedItem !== null;
      };

      /**
        * this method can be used to set the focus of the element
        *
        * @method indexOf
        */
      focus() {
        this.$.inputValue.focus();
      };

      /**
        * This method will automaticly set the label float.
        */
      _computeAlwaysFloatLabel(_token, alwaysFloatLabel) {
        if (alwaysFloatLabel) {
          return true;
        }
        return !((_token === undefined || _token === null) && this.$.inputValue !== document.activeElement);
      };

      _handleContainerTap(e) {
        this.opened = true;
        Polymer.RenderStatus.afterNextRender(this, _ => this.focus());
      };

      reset() {
        this._resetInput();
        this.set('selectedItem', null);
        this.set('selected', null);
      };

      _resetInput() {
        if (this.autoValidate) {
          this.validate();
        }
        this._inputValue = '';
        this.focus();
      };

      _showLabel(_token) {
        console.log('init');
        
        if (_token) {
          console.log('token :::: ', _token);

          return _token.text;
        }

        return this.label;
      }

      /**
      * Returns true if `value` is valid.
      * @return {boolean} True if the value is valid.
      */
      validate() {
        this.invalid = this.required && !this._hasSelectedItem();
        return !this.invalid;
      };
    }
    window.customElements.define(PaperComboboxElement.is, PaperComboboxElement);
    /**
      * @namespace Exmg
    */
    window.Exmg = window.Exmg || {};
    Exmg.PaperComboboxElement = PaperComboboxElement;
  }
  </script>
</dom-module>