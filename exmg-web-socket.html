<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="exmg-web-socket">
  <script>
    /**
     * `exmg-web-socket`
     *
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */

  (function() {
    const CONNECTING = 0;
    const OPEN = 1;
    const CLOSING = 2;
    const CLOSED = 3;

    class ExmgWebSocket extends Polymer.Element {
      static get is() { return 'exmg-web-socket'; }
      static get properties() {
        return {
          /**
           * Automaticly setup connection on init
           */
          auto: {
            type: Boolean,
            value: false
          },
          /*
           * Interval in which we reconnect after connection error
           */
          autoReconnectInterval: {
            type: Number,
            value: 300,
          },
          /**
           * By default, exmg-web-socket events do not bubble. Setting this attribute will cause its
           * events to bubble to the window object.
           */
          bubbles: {
            type: Boolean,
            value: false
          },
          /**
           * The URL to which to connect; this should be the URL to which the WebSocket server will respond.
           */
          url: {
            type: String,
            notify: true
          },
          /**
           * Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,
           * so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to
           * be able to handle different types of interactions depending on the specified protocol). If you don't specify a
           * protocol string, an empty string is assumed.
           */
          protocols: {
            type: Array,
            value: []
          },
          /**
           * Specifies the format in which the data is send.
           */
          handleAs: {
            type: String,
            value: 'json'
          },
          /**
           * The most recent request made by this web-socket element.
           * @type {Object}
           */
          lastRequest: {
            type: Object,
            notify: true,
            readOnly: true
          },
          /**
           * The most recent response received by this web-socket element.
           * @type {Object}
           */
          lastResponse: {
            type: Object,
            notify: true,
            readOnly: true
          },
          /**
           * The most recent error received by this web-socket element. If any error occurred.
           * @type {Object}
           */
          lastError: {
            type: Object,
            notify: true,
            readOnly: true
          },
          /**
           * Enables verbose mode
           */
          verbose: {
            type: Boolean,
            value: false
          }
        };
      }

      get socket() {
        return this._socket;
      }

      get readyState() {
        return this._socket && this._socket.readyState;
      }

      fire(eventName, obj) {
        if (this.verbose) {
          console.log('CustomEvent Fired', eventName, {bubbles: this.bubbles, composed: true, detail: obj});
        }
        this.dispatchEvent(new CustomEvent(eventName, {bubbles: this.bubbles, composed: true, detail: obj}));
      }

      constructor() {
        super();
        this._boundOnError = this._onError.bind(this);
        this._boundOnClose = this._onClose.bind(this);
        this._boundOnMessage = this._onMessage.bind(this);
        this._boundOnOpen = this._onOpen.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        if (this.auto) {
          this.connect();
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeSocketListeners();
      }

      send(message) {
        if(!this.socket || this.readyState !== OPEN) {
          console.error(`Error sending message ${message} [readyState: ${this.readyState}]`);
          return;
        }
        this._socket.send(message);
      }

      close() {
        if(!this.socket || this.readyState !== OPEN) {
          if(this.verbose) {
            console.warn(`Unable to close WebSocket connection because it is not open`);
          }
          return;
        }
        this._forceClose = true;
        this.socket.close(1000);
      }

      connect() {
        if(this.socket && this.readyState !== CLOSED) {
          if(this.verbose) {
            console.warn(`Unable to connect becuase socket already active`);
          }
          return;
        }
        this._initializeWebSocket();
      }

      _reconnect() {
        if(this.verbose) {
          console.log(`Connection retry in ${this.autoReconnectInterval}ms`);
        }

        setTimeout(() => {
          if(this.verbose) {
            console.log('reconnecting...');
          }
          this.connect();
        }, this.autoReconnectInterval);
      }

      _onError(e) {
        if (this.verbose) {
          console.error(`Connection error received`, e);
        }
        this.fire('error', e);
        this._setLastError(e);
      }

      _onClose(e) {
        if (this.verbose) {
          console.info(`Connection Closed [code: ${e.code}, forceClose: ${this._forceClose}]`);
        }
        if(!this._forceClose) {
          this._reconnect();
        }
        this.fire('close');
        this._setLastResponse(null);
      }

      _onMessage(e) {
        if (this.verbose) {
          console.info(`Message received`, e.data);
        }
        this.fire('message', e);
        this._setLastResponse(e.data);
      }

      _onOpen(e) {
        if (this.verbose) {
          console.info(`Connection open received [readyState: ${this.readyState}]`);
        }
        this.fire('open', e);
      }

      _initializeWebSocket() {
        if (this.verbose) {
          console.info(`Initialize WebSocket [url: ${this.url} / protocols: ${this.protocols}]`);
        }
        if(!this.url) {
          console.error(`Please provide a valid WebSocket url ${this.url}`);
          return;
        }
        try {
          this._socket = new WebSocket(this.url, this.protocols || []);
        } catch (e) {
          if (this.verbose) {
            console.error(`Error initializing WebSocket from url ${this.url} (${e})`);
          }
          this._setLastError(e);
        }
        this._forceClose = false;
        this._addSocketListeners();
      }

      _addSocketListeners() {
        this._socket.addEventListener('error', this._boundOnError);
        this._socket.addEventListener('close', this._boundOnClose);
        this._socket.addEventListener('message', this._boundOnMessage);
        this._socket.addEventListener('open', this._boundOnOpen);
      }

      _removeSocketListeners() {
        if(this._socket) {
          socket.removeEventListener('error', this._boundOnError);
          socket.removeEventListener('close', this._boundOnClose);
          socket.removeEventListener('message', this._boundOnMessage);
          socket.removeEventListener('open', this._boundOnOpen);
        }
      }
    }

    window.customElements.define(ExmgWebSocket.is, ExmgWebSocket);
  })();
  </script>
</dom-module>
